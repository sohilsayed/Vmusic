# Holodex Music Project: Sync & Architecture Protocol

This document defines the architectural rules, synchronization logic, and API constraints for the Holodex Music Android application. It is the authoritative guide for maintaining the "Hybrid Data" model.

## 1. Architecture Overview

*   **Pattern:** MVVM + Orbit MVI.
*   **Database:** Room (SQLite).
*   **Dependency Injection:** Hilt.
*   **Network:** Retrofit + OkHttp.
*   **External Data:** NewPipeExtractor (for YouTube scraping).

## 2. The "Hybrid Data" Model

The application manages two distinct types of data that must coexist but remain technically isolated to prevent server corruption.

### A. Data Classifications

1.  **Synced Data (Holodex):**
    *   Source: Holodex API (`holodex.net`, `music.holodex.net`).
    *   Identifiers: Holodex UUIDs (e.g., `550e8400-e29b...`) or Channel IDs.
    *   Storage: `liked_items`, `playlist_items`, `favorite_channels`.
    *   Sync Status: Managed via `SyncStatus` enum (`SYNCED`, `DIRTY`, `PENDING_DELETE`).

2.  **Local-Only Data (External):**
    *   Source: YouTube (via NewPipe).
    *   Identifiers: YouTube Video IDs (e.g., `dQw4w9WgXcQ`).
    *   Storage: `local_favorites`, `external_channels`, or `playlist_items` (flagged).
    *   **Strict Rule:** These items must **NEVER** be sent to the Holodex API.

### B. Storage Strategy

| Feature | Synced Storage Table | Local-Only Storage Table | Separation Mechanism |
| :--- | :--- | :--- | :--- |
| **Likes** | `liked_items` (type: `SONG_SEGMENT`) | `local_favorites` | Physical Table Separation |
| **Channels** | `favorite_channels` | `external_channels` | Physical Table Separation |
| **Playlists** | `playlist_items` | `playlist_items` | Logical Flag: `is_local_only = 1` |

---

## 3. Synchronization Logic (Upload & Download)

### A. Upstream Sync (Upload: Local -> Server)

**Trigger:** `SyncWorker` runs (periodic or manual). It queries for items with `SyncStatus.DIRTY` or `PENDING_DELETE`.

1.  **Playlists (`PlaylistSynchronizer`):**
    *   **Constraint:** Server requires a full snapshot of the playlist content (List of UUIDs).
    *   **Filtering:** The repository fetches all items for the playlist but **filters out** any item where `isLocalOnly == true`.
    *   **Action:** Sends `POST` with the filtered list of UUIDs.
    *   **Result:** Server has a clean list of Holodex songs; Local DB retains mixed list.

2.  **Likes (`LikesSynchronizer`):**
    *   **Constraint:** Server only accepts Song UUIDs.
    *   **Filtering:** The synchronizer *only* queries the `liked_items` table. It completely ignores `local_favorites`.
    *   **Action:** Sends `POST` (add) or `DELETE` (remove) for specific UUIDs.

3.  **Channels (`FavoriteChannelSynchronizer`):**
    *   **Constraint:** Server requires a `PATCH` diff.
    *   **Filtering:** Ignores `external_channels`.
    *   **Action:** Constructs a JSON array of ops: `[{ "op": "add", "channel_id": "..." }]`.

### B. Downstream Sync (Download: Server -> Local)

**Trigger:** Server timestamp > Local timestamp.

1.  **Playlists (The "Non-Destructive Merge"):**
    *   **Problem:** A standard sync would delete all local items and replace them with the server list, wiping out external songs.
    *   **Solution:** `reconcileLocalPlaylistItems` function.
        1.  Fetch current local items.
        2.  Separate `isLocalOnly` items into a safe list.
        3.  Fetch new server items.
        4.  **Merge:** Create a new list = `ServerItems + LocalOnlyItems`.
        5.  **Atomic Update:** Save the merged list to the DB.
    *   **Metadata Update:** Use `@Query("UPDATE playlists SET...")` instead of `@Update` to prevent triggering Room's `CASCADE DELETE` on child items.

2.  **Likes & Channels:**
    *   **Strategy:** "Smart Reconcile".
    *   Fetch server list.
    *   Fetch local list (from the synced table only).
    *   **Insert:** Items on server but not local.
    *   **Delete:** Items local (`SYNCED`) but not on server.
    *   **Ignore:** Items local (`DIRTY` or `PENDING_DELETE`) to preserve pending user actions ("Zombie Prevention").

---

## 4. Server API Quirks & constraints

| Resource | Method | Critical Constraints |
| :--- | :--- | :--- |
| **Playlists** | `POST` | Requires full content array. Sending unknown fields (e.g., `is_deleted`) causes **500 Error**. Use `PlaylistUpdateRequest` DTO. |
| **Channels** | `PATCH` | Requires diff array. Cannot handle full snapshot. |
| **Likes** | `POST` | Requires `song_id` (UUID). Cannot accept `video_id`. |
| **Virtual Segments** | N/A | A full video liked as a song (start: 0) has no UUID. Treat as **Local-Only** (`local_favorites` or `liked_items` type `VIDEO`). |

## 5. Authentication Headers

*   **Client:** `OkHttpClient` provided by Hilt.
*   **Public Endpoints:** Use `@HolodexHttpClient`. Adds `X-APIKEY`.
*   **User Endpoints:** Use `@AuthenticatedMusicdexHttpClient`. Adds `X-APIKEY` **AND** `Authorization: Bearer <JWT>`.
    *   *Warning:* Calling authenticated endpoints without a JWT causes `401 Unauthorized`. ViewModels must check `TokenManager` before attempting sync actions.

---

## 6. Navigation & Data Passing

To prevent redundant network calls and API errors:

1.  **Primary Mechanism (Smart Dispatch):** ViewModels (`VideoDetailsViewModel`, `ChannelDetailsViewModel`) must not assume data availability.
    *   **Step 1:** Check for cached/pre-fetched data (e.g., via a shared Activity-scoped ViewModel).
    *   **Step 2:** If missing, try Holodex API.
    *   **Step 3:** If Holodex returns `404` (External ID) or fails, fall back to `NewPipeExtractor` (External Source).

2.  **Data Normalization (Virtual Segments):**
    *   The app treats **all** playable items as "Segments."
    *   **Holodex Songs:** Have specific `start` and `end` times.
    *   **Full Videos / External Videos:** Converted to a "Virtual Segment" where `start = 0` and `end = duration`.
    *   **Benefit:** The UI and Player only need logic for one data type (`PlaybackItem`).

## 7. UI State Management (Orbit MVI)

*   **Rule:** Complex screens (`FavoritesScreen`, `VideoListScreen`) must use **Orbit MVI**.
*   **Syntax:** Use `container.orbit {}` or `intent {}`. Do not use deprecated syntax.
*   **Single Source of Truth:**
    *   Do not expose multiple `StateFlows` for data that needs to be combined.
    *   Use `combine` inside the ViewModel's `init` or `observe` intent to merge all data sources (DB tables, preferences) into a **single** `State` object.
    *   The UI should verify state consistency (e.g., "Is this item liked?") against this single state object, not by querying repositories directly.

## 8. Image Loading Optimization

*   **Problem:** Loading high-res thumbnails in small list items causes jank.
*   **Rule:** Always use `Coil`'s `.size(ViewSize)` modifier in list adapters (`UnifiedListItem`).
*   **Constraint:** Do not use `ThumbnailQuality.MAX` for list items; use `ThumbnailQuality.MEDIUM` or let Coil downsample. Only use `MAX` for detail screens or hero banners.